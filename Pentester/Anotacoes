WHERE SYSCALL IS LOCALIZADO:
/usr/include/asm/unistd_64.h
or /usr/include/x86_64-linux-gnu/asm/unistd_64.h

nasm -felf64 Logical-64.nasm -o 

24/05/2025
$ nasm -felf64 MovingData64.nasm -o MovingData64.o
$ ld MovingData64.o -o MovingData64
$ gdb -q ./MovingData-64 -tui
(gdb) set disassembly-flavor intel

Starting program: /workspaces/Assembly/Pentester/MovingData64

Breakpoint 1, 0x0000000000401000 in _start ()
(gdb) layout asm
(gdb) layout regs
(gdb) 

31/05/2025
STACK
Stack is LIFO
hIGH MEMORY TO LOW MEMORY --> RSP Deve apontar para o topo do Stack


(gdb) set disassembly-flavor intel
(gdb) break _start
(gdb) run
(gdb) layout asm
(gdb) layout regs
#####DEFINIR HOOK STOP#######
(gdb) define hook-stop
> x/4xg $rsp --> acompanhar os Ãºltimos 4 valores do Stack
> end

CLC : Clear Carry Flag
STC : Set Carry Flag
CMC : Complements the carry flag (CF). This means it flips the state of the carry flag from 0 to 1 or from 1 to 0. It does not affect any other flags
ADC : ADD Carry flag to result
SBB : Subtracts the source from the destination, and subtracts 1 extra if the Carry Flag is set.


2. Editing the file:

    Using a text editor: Open the .gdbinit file in your preferred text editor. For example, to use nano, you would run nano ~/.gdbinit. 

Adding commands: Inside the .gdbinit file, you can add any GDB commands you want to be executed automatically when GDB starts. This might include setting breakpoints, defining aliases, or loading specific libraries. 
Saving the file: After making your changes, save the file. 

(gdb) x/64xb &message
0x402000:       0x48    0x65    0x6c    0x6c    0x6f    0x20    0x57    0x6f
0x402008:       0x72    0x6c    0x64    0x21    0x20    0x0a    0x00    0x00
0x402010:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402018:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402020:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402028:       0x01    0x00    0x00    0x00    0x04    0x00    0xf1    0xff
0x402030:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402038:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
"Hello World! "

In x86-64 architecture, rsp and rip are special purpose registers with specific roles.
 rsp is the stack pointer, which keeps track of the top of the stack, while rip is 
 the instruction pointer, which holds the memory address of the next instruction to be executed
