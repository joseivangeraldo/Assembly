PARA SINCRONIZAR AS ULTIMAS ALTERAÇÕES.
$ git pull

$ sudo apt-get update
$ nasm -f elf64 hello.asm
$ ls
hello.asm  hello.o

$ ld -s -o hello hello.o
$ ls
hello  hello.asm  hello.o

;;;SECOES DE UM PROGRAMA EM ASSEMBLY

section .data   ;;colocamos as constantes

section .text   ;;ficam as variaveis

global _start       ;;tem de ter obrigatorio

_start:     ;;ponto de entrada

    mov EAX, 0x1      ;;destino, origem ESTOU TERMINANDO O PROGRAMA
    mov EBX, 0x0      ;; O VALOR DE RETORNO É ZERO,
    int 0x80        ;; O SO Pega todas as movimentações e executa

SEMPRE TEM DE USAR USAR OS REGISTRADORES.

TABELA DA VERDADE:
    AND     OR      XOR
7 - 0111    0111    0111
5 - 0101    0101    0101
    0101    0111    0010
     5       7        2  >> É  A DIFERENÇA

MAKEFILE:
NOME = entrada

all: $(NOME).o
	ld -s -o $(NOME) $(NOME).o
	rm -rf *.o;

%.o: %.asm
	nasm -f elf64 $<

    ivan@ivan-Inspiron-3437:~$ xev --> ver valores binarioos teclado


 Update the package lists.
Code

    sudo apt-get update

install nasm.
Code

    sudo apt-get install nasm


{
  "image": "mcr.microsoft.com/devcontainers/universal:2",
  "features": {
    "ghcr.io/devcontainers/features/github-cli:1": {}
  },
    "customizations": {
    "vscode": {
      "extensions": [        
        "GitHub.copilot",
        "ms-vscode.azure-account",
        "ms-azuretools.vscode-azurestaticwebapps"
      ]
    }
  }
}


I'll first summarize safe options for "erasing" commit history and ask a couple quick questions so I don't run any destructive commands without your OK.

Short options (pick one)

Keep current files, replace history with a single new root commit (recommended). Old history preserved in a backup branch locally (and optionally on remote). Requires a force-push to replace remote history.
Remove specific commits or sensitive files from history (use git filter-repo or BFG). Useful if you need to redact sensitive data but keep other history.
Start a brand-new repository (delete .git and run git init). This removes all history locally; you'd lose link to remotes unless you re-add them and force-push.
Risks and notes

Rewriting history and force-pushing will rewrite commit SHAs. Anyone who cloned/forked the repo will need to rebase or re-clone. This is disruptive.
I will never run destructive commands (force-push, delete .git, etc.) until you explicitly confirm.
I'll create a backup branch/tag before any destructive action so you can restore if needed.
Quick questions

Which branch do you want to clean? (default: main)
Do you want to keep a backup of the current history? (recommended: yes)
Do you want me to perform the change and force-push to the remote, or just prepare the local clean branch so you can review and push manually?
If you want the "single commit" approach, here's the safe sequence I will run once you confirm (I can run it for you):

Inspect current state (non-destructive):
Show recent commits and remotes:
git status
git branch --show-current
git --no-pager log --oneline --decorate --graph -n 30
git remote -v
Create a backup branch (non-destructive):
git branch backup-before-cleanup
git tag backup-before-cleanup-<date>
Create a new orphan branch with current files and one commit:
git checkout --orphan clean-history
git reset --hard
git add -A
git commit -m "chore: clean history — snapshot of current state"
(optional) Rename branches:
git branch -M clean-history main-clean # local only
Replace remote branch (ONLY IF YOU CONFIRM and understand the risk):
git push --force origin clean-history:main
or to replace default branch directly:
git push --force origin clean-history:main
Verify remote and optionally delete local backup.
If you're ready, tell me:

target branch name (e.g., main),
whether to create backups (yes/no),
whether to force-push to the remote (yes/no).
If you'd like, I can run the non-destructive inspection commands now so you can see the current state before deciding. Which would you like
   

